<link rel="import" href="../../bower_components/polymer/polymer.html">


<polymer-element name="conductoor-create-phase-form" attributes="editMode phases currentPhase">
  <template>
    <link rel="stylesheet" href="conductoor-create-phase-form.css">

      <template if="{{!editPhase}}"><h2>New phase: {{phaseName}}</h2></template>
      <template if="{{editPhase}}"><h2>Editing: {{phaseName}}</h2></template>

      <div id="error_messages">
        <template repeat="{{error in errors}}">
          <template if="{{error.show}}">
            <div class="error" visible?="{{!error.show}}">{{error.message}}</div>
          </template>
        </template>
      </div>

      <form id="createProjectForm" on-submit="{{validateForm}}">
        <div layout horizontal>
          <div flex class="card">
            <paper-input-decorator floatingLabel label="Phase name" id="phaseNameDecorator">
              <input is="core-input" required maxlength="30" on-input="{{validatePhaseName}}" error="This field is required" type="text" value="{{phaseName}}">
            </paper-input-decorator>
            <br>
            <div layout horizontal>
              <paper-input-decorator flex label="Start" style="margin-right:10px;">
                <label>Start date:</label><input is="core-input" type="date" required startDate on-input="{{validateInput}}" value="{{phaseStart}}"></input>
              </paper-input-decorator>
              <paper-input-decorator flex label="End">
                <label>End date:</label><input is="core-input" type="date" required endDate on-input="{{validateInput}}" value="{{phaseEnd}}"></input>
              </paper-input-decorator>
            </div>
            <br>
            <paper-input-decorator label="Desription" floatingLabel>
              <paper-autogrow-textarea>
                <textarea maxlength="200" value="{{phaseDescription}}"></textarea>
              <paper-autogrow-textarea>
            </paper-input-decorator>
          </div>
          <div flex class="card">
            <h3>Select skills for phase:</h3>
            <div layout horizontal>
              <div flex four>
                <core-selector id="selectSkills" selected="{{selectedSkills}}" multi valueattr="skill">
                  <template repeat="{{skill in skills}}">
                      <div class="skill" skill="{{skill.name}}" on-click="{{updateFormValidity}}">{{skill.name}}</div>
                  </template>
                </core-selector>
              </div>
              <div flex two>
                <template repeat="{{skill in skills}}">
                  <div class="skill-hours">
                      <core-field>
                        <core-icon icon="alarm"></core-icon>
                        <paper-input-decorator label="hours">
                          <input min="0" class="hours" skillName="{{skill.name}}" on-input="{{mapHoursToSkill}}">
                        </paper-input-decorator>
                      </core-field>
                    </div>
                </template>
              </div>
            </div>
          </div>
        </div>
        <br>
        <!-- paper-buttonilla submit ei toimi... -->
        <template if="{{!editPhase}}">
          <button id="submit" disabled?="{{formInvalid}}" visible?="{{formInvalid || editPhase}}" type="submit" style="background:transparent;border:none;"><paper-button disabled?="{{formInvalid}}" raised>Add phase to project</paper-button></button>
        </template>
        <template if="{{editPhase}}">
          <button id="submit" visible?="{{formInvalid || !editPhase}}" type="submit" style="background:transparent;border:none;"><paper-button disabled?="{{formInvalid}}" raised>Save</paper-button></button>
         <paper-button raised on-click="{{clearForm}}">Reset</paper-button>
        </template>
      </form>
      <paper-toast id="addSuccess" text="Phase added"></paper-toast>
      <paper-toast id="addError" text="Could not add phase. Check your inputs!"></paper-toast>

  </template>


  <script>
    (function () {
      Polymer({
        created: function(){
          // missä muodossa skillit tulee?
          // TODO fetch skills
          this.skills = [{"name":"skill1"}, {"name":"skill2"}, {"name":"skill3"}, {"name":"skill4"}, {"name":"skill5"}];
          this.selectedSkills = [];   // Tyyppiä? [{"name":"skill1", "hours":"40"}, {"name":"skill2", "hours":"40"}];
          this.hours = [];            // Tyyppiä [{"skill":"skill1", "hours": "40"}]
          this.phaseName = "";
          this.phaseStart = "";
          this.phaseEnd = "";
          this.phaseDescription = "";
          this.phaseColor = "#000";
          this.editPhase = false;
          this.formInvalid = true;
          this.errors = [
            {"error":"dateWrongOrder", "message":"Start date needs to be before end date.", "show":false},
            {"error":"descriptionTooLong", "message":"Maximum length of description is 200 characters.", "show":false},
            {"error":"phaseNameExists", "message":"Already exists phase with that name.", "show":false},
            {"error":"hoursError", "message":"Hour needs to be a positive number.", "show":false},
            {"error":"dateWrongFormat", "message":"Select date with the date picker.", "show":false}
          ];
        },

        /*
        ////////////////////
        // FUNCTIONALITIES
        ////////////////////
        */

        // phaseStartChanged ja phaseEndChanged pitää poistaa kun date input validation toimii...
        phaseStartChanged: function(){
          var dateFormatError = _.findWhere(this.errors, {error:"dateWrongFormat"});
          var dateWrongOrderError = _.findWhere(this.errors, {error:"dateWrongOrder"});
          dateFormatError.show = false;
          dateWrongOrderError.show = false;
          this.updateFormValidity();
        },
        phaseEndChanged: function(){
          var dateFormatError = _.findWhere(this.errors, {error:"dateWrongFormat"});
          var dateWrongOrderError = _.findWhere(this.errors, {error:"dateWrongOrder"});
          dateFormatError.show = false;
          dateWrongOrderError.show = false;
          this.updateFormValidity();
        },
        selectedSkillsChanged: function(){
          this.updateFormValidity();
        },
        currentPhaseChanged: function(){
          if(this.currentPhase){
            this.phaseName = this.currentPhase.name;
            this.phaseStart = this.currentPhase.start;
            this.phaseEnd = this.currentPhase.end;
            this.phaseDescription = this.currentPhase.description;
            this.phaseColor = this.currentPhase.color;
            // select skills
            //var all_hours = this.shadowRoot.querySelectorAll(".hours");
            var hour_input;
            for (var i =0 ; i <= this.currentPhase.skills.length - 1; i++) {
              hour_input = this.shadowRoot.querySelector(".hours[skillName='"+this.currentPhase.skills[i].name+"']");
              hour_input.value = this.currentPhase.skills[i].hours;
              this.hours.push({"skill":this.currentPhase.skills[i].name, "hours":this.currentPhase.skills[i].hours});
              this.selectedSkills.push(this.currentPhase.skills[i].name);
            }
            this.formInvalid = false;
            this.editPhase = true;
          }
        },
        mapHoursToSkill: function(event, detail, sender){
          var hours = sender.value;
          var skill = sender.getAttribute("skillName");
          if(this.validateHours(hours) && _.contains(this.selectedSkills, skill)){
            // check if hours has changed
            if( _.findWhere(this.hours, {skill:skill}) ){
              var idx = _.indexOf(_.pluck(this.hours, 'skill'), skill);
              this.hours[idx].hours = hours;
            }
            else
              this.hours.push({"skill":skill, "hours":hours});
          }
          this.updateFormValidity();
        },
        createPhase: function(){
          // generate random color --> works as ID?
          this.phaseColor = this.editPhase ? this.phaseColor : this.getRandomColor();
          // create skill objects
          var skills = [];
          for (var i = this.selectedSkills.length - 1; i >= 0; i--) {
            var hours = _.findWhere(this.hours, {skill:this.selectedSkills[i]});
            // add to skills only when skill has hours set!
            if(hours){
              skills.push({"name":this.selectedSkills[i], "hours":hours.hours});
            }
            else{
              skills.push({"name":this.selectedSkills[i], "hours":0});
            }
          }
          var phase = {"name":this.phaseName, "start":this.phaseStart, "end":this.phaseEnd, "description": this.phaseDescription, "color":this.phaseColor, "skills":skills};
          return phase;
        },
        addPhase: function(){
          var phase = this.createPhase();
          // Add new phase
          if (!this.editPhase) {
            this.phases.push(phase);
            this.$.addSuccess.show();
          }
          // Update existing phase
          else if(this.editPhase){
            var idx = _.indexOf(_.pluck(this.phases, 'color'), phase.color);
            this.phases[idx] = phase;
          }
          this.clearForm();
        },


        /*
        //////////////////////
        // INPUT VALIDATIONS
        //////////////////////
        */
        validateHours: function(n) {
          var hoursError = _.findWhere(this.errors, {error:"hoursError"});
          // show error messages if necessary
          if( isNaN(parseFloat(n)) || parseFloat(n) < 0){
            if(n){
              hoursError.show = true;
              this.hoursValid = false;
            }
            else{
              hoursError.show = false;
              this.hoursValid = true;
            }
          }
          else{
            hoursError.show = false;
            this.hoursValid = true;
          }
          return !isNaN(parseFloat(n)) && isFinite(n) && parseFloat(n) > 0;
        },
        validateColor: function(color){
          var colors = _.map(this.phases, "color");   // color is considered as the id of a phase --> unique!
          console.log("color alreay exists: "+_.contains(colors, color));
          return _.contains(colors, color);
        },
        validatePhaseName: function(event, detail, sender){
          var phaseNameError = _.findWhere(this.errors, {error:"phaseNameExists"});
          var is_input = (event || detail || sender) ? true : false;
          var phaseName = is_input ? sender.value : this.phaseName;

          if(is_input)
            this.validateInput(event);
            
          for (var i = this.phases.length - 1; i >= 0; i--) {
            if (this.phases[i].name === phaseName && !this.editPhase){
              phaseNameError.show = true;
              if(!is_input)
                return false;
            }
            else{
              phaseNameError.show = false;
            }
          }
          this.updateFormValidity();

          if(!is_input)
            return true;
        },
        validateDate: function(){
          // TODO --> input validation....
          var re = /^(\d{4})-(\d{1,2})-(\d{1,2})$/;
          var dateFormatError = _.findWhere(this.errors, {error:"dateWrongFormat"});
          var dateWrongOrderError = _.findWhere(this.errors, {error:"dateWrongOrder"});

          // check date format
          if ( !this.phaseStart.match(re) || !this.phaseEnd.match(re) ){
            dateFormatError.show = true;
            return false;
          }
          else{
            dateFormatError.show = false;
          }  
          // check date order
          if( this.parseDate(this.phaseStart) > this.parseDate(this.phaseEnd) ){
            dateWrongOrderError.show = true;
            return false;
          }
          else{
            dateWrongOrderError.show = false;
          }
          return true;
        },
        validateDescription: function(){
          if(this.phaseDescription){
            if (this.phaseDescription.length > 200)
              return false;
            else
              return true
          }
          return true;
        },
        validateInput: function(e){
          // default validation --> uses inputs own validators (min, required etc.)
          var d = e.target.parentNode;
          d.isInvalid = !e.target.validity.valid;
          this.updateFormValidity();
        },
        validateForm: function(e) {
          e.preventDefault();
          // Do final validation of data
          var valid = true;
          if(this.phaseName.length > 30 || this.phaseName.length === 0){
            valid = false;
          }
          // strip tags
          this.phaseName = this.phaseName.replace(/(<([^>]+)>)/ig,"");
          this.phaseDescription = this.phaseDescription.replace(/(<([^>]+)>)/ig,"");

          valid = this.validatePhaseName();
          valid = this.validateDescription();
          valid = this.validateDate();

          if(this.selectedSkills.length === 0)
            valid = false;
          // if has errors
          if( _.findWhere(this.errors, {show:true}) )
            valid = false;
          // if data valid --> add phase
          valid === true ? this.addPhase() : this.$.addError.show();
        },










        /*
        /////////////////
        // FORM CONTROL
        /////////////////
        */
        updateFormValidity: function(){
          var myform = this.$.createProjectForm;
          var invalid = false;
          // check validity of form fields
          Array.prototype.forEach.call(myform, function(child) {
            if (child.validity.valid === false) {
              invalid = true;
            }
          });
          if(!this.selectedSkills.length)
            invalid = true;
          if( _.findWhere(this.errors, {show:true}) )
            invalid = true;
          this.formInvalid = invalid;
        },
        clearForm: function(){
          this.$.createProjectForm.reset();
          // reset variables
          this.selectedSkills = [];
          // pelkkä reset ei riitä --> phase edit ei toimi normisti
          this.phaseName = "";
          this.phaseStart = "";
          this.phaseEnd = "";
          this.phaseDescription = "";
          this.phaseColor = "#000";
          this.formInvalid = true;
          this.editPhase = false;
          this.currentPhase = null;
          this.hours = [];
        },


        /*
        /////////////////
        // OTHERS
        /////////////////
        */
        getRandomColor: function() {
          var letters = '0123456789ABCDEF'.split('');
          var color = ''; //#
          for (var i = 0; i < 6; i++ ) {
              color += letters[Math.floor(Math.random() * 16)];
          }
          return this.changeLuminance(color, -0.4);
        },
        changeLuminance: function(hex, lum) {
          // validate hex string
          hex = String(hex).replace(/[^0-9a-f]/gi, '');
          if (hex.length < 6) {
            hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
          }
          lum = lum || 0;
          // convert to decimal and change luminosity
          var rgb = "", c, i; //#
          for (i = 0; i < 3; i++) {
            c = parseInt(hex.substr(i*2,2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ("00"+c).substr(c.length);
          }
          // check that color is unique
          if (this.validateColor(rgb)){
            getRandomColor();
          }
          else{
            return rgb;
          }
        },
        parseDate: function(s) {
          var b = s.split(/\D/);
          return new Date(b[0], --b[1], b[2]);
        }
        
      });
    })();
  </script>
</polymer-element>
